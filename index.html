<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Telegram Platformer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style> body,html { margin:0; height:100%; } #game { width:100%; height:100vh; } </style>
</head>
<body>
  <div id="game"></div>
  <script>
  // Optional: Telegram WebApp init (if available)
  const tg = window.Telegram.WebApp || null;
  const initData = tg ? tg.initData : null;

  // Phaser basic platformer without external assets (graphics rectangles)
  const config = {
    type: Phaser.AUTO,
    width: Math.min(window.innerWidth, 1024),
    height: Math.min(window.innerHeight, 768),
    parent: 'game',
    physics: {
      default: 'arcade',
      arcade: { gravity: { y: 1000 }, debug: false }
    },
    scene: {
      preload: preload,
      create: create,
      update: update
    }
  };

  const game = new Phaser.Game(config);

  let player, cursors, platforms, score = 0, scoreText, enemies;

  function preload() {
    // no external assets â€” we'll use graphics
  }

  function create() {
    // background
    this.add.rectangle(0, 0, config.width*2, config.height*2, 0x87CEEB).setOrigin(0);

    // platforms group (static)
    platforms = this.physics.add.staticGroup();
    // ground
    platforms.create(config.width/2, config.height - 16, null).setDisplaySize(config.width, 32).refreshBody();
    // some floating platforms
    platforms.create(150, config.height - 120, null).setDisplaySize(200, 20).refreshBody();
    platforms.create(420, config.height - 220, null).setDisplaySize(180, 20).refreshBody();
    platforms.create(720, config.height - 320, null).setDisplaySize(160, 20).refreshBody();

    // draw platform rectangles (visual)
    platforms.getChildren().forEach(p => {
      const g = this.add.graphics();
      g.fillStyle(0x8B4513, 1);
      g.fillRect(p.x - p.displayWidth/2, p.y - p.displayHeight/2, p.displayWidth, p.displayHeight);
    });

    // player as rectangle
    player = this.physics.add.sprite(100, config.height - 150, null);
    player.displayWidth = 36; player.displayHeight = 48;
    player.body.setSize(player.displayWidth, player.displayHeight);
    player.setCollideWorldBounds(true);

    // draw player
    player.draw = this.add.graphics();
    player.draw.fillStyle(0xff0000, 1);
    player.draw.fillRect(-player.displayWidth/2, -player.displayHeight/2, player.displayWidth, player.displayHeight);
    player.add(player.draw);

    this.physics.add.collider(player, platforms);

    // simple enemy group
    enemies = this.physics.add.group();
    const e = enemies.create(500, config.height - 250, null);
    e.displayWidth = 32; e.displayHeight = 32; e.body.setSize(e.displayWidth,e.displayHeight);
    e.setVelocityX(50);
    e.setBounce(1,0);
    e.setCollideWorldBounds(true);
    e.draw = this.add.graphics(); e.draw.fillStyle(0x000000,1); e.draw.fillRect(-e.displayWidth/2, -e.displayHeight/2, e.displayWidth, e.displayHeight); e.add(e.draw);
    this.physics.add.collider(enemies, platforms);
    this.physics.add.collider(player, enemies, hitEnemy, null, this);

    // input
    cursors = this.input.keyboard.createCursorKeys();

    // score display
    scoreText = this.add.text(16,16, 'Score: 0', { font: '20px Arial', fill: '#000' });

    // touch controls for mobile: simple left/right/jump zones
    this.input.on('pointerdown', (pointer) => {
      if (pointer.x < config.width/3) leftDown = true;
      else if (pointer.x > config.width*2/3) rightDown = true;
      else tryJump();
    });
    this.input.on('pointerup', () => { leftDown = rightDown = false; });

    // camera follow
    this.cameras.main.startFollow(player, true, 0.1, 0.1);
    this.cameras.main.setBounds(0,0,config.width*2,config.height);
    this.physics.world.setBounds(0,0,config.width*2,config.height);
  }

  let leftDown=false, rightDown=false;
  function tryJump() {
    if (player.body.touching.down) {
      player.setVelocityY(-450);
    }
  }

  function hitEnemy(playerObj, enemyObj) {
    // if player is falling (jumping on enemy) -> kill enemy
    if (playerObj.body.velocity.y > 0) {
      enemyObj.destroy();
      score += 100;
      scoreText.setText('Score: ' + score);
    } else {
      // otherwise, game over
      gameOver();
    }
  }

  function gameOver() {
    // send score to backend
    sendScore(score);
    // show simple overlay
    const style = { font: '32px Arial', fill: '#000' };
    this.add.text(config.width/2 - 120, config.height/2 - 20, 'Game Over\nScore: ' + score, style);
    this.scene.pause();
  }

  function update() {
    // movement
    const speed = 200;
    if (cursors.left.isDown || leftDown) {
      player.setVelocityX(-speed);
    } else if (cursors.right.isDown || rightDown) {
      player.setVelocityX(speed);
    } else {
      player.setVelocityX(0);
    }
    if ((cursors.up.isDown || cursors.space.isDown) && player.body.touching.down) {
      player.setVelocityY(-450);
    }

    // update drawn rectangles for player and enemies (Phaser sprite has no texture)
    player.draw.clear(); player.draw.fillStyle(0xff0000,1); player.draw.fillRect(player.x - player.displayWidth/2, player.y - player.displayHeight/2, player.displayWidth, player.displayHeight);
    enemies.getChildren().forEach(en => { if (en.draw) { en.draw.clear(); en.draw.fillStyle(0x000000,1); en.draw.fillRect(en.x - en.displayWidth/2, en.y - en.displayHeight/2, en.displayWidth, en.displayHeight); } });

    // increase score slowly as survival incentive
    score += 0.02;
    scoreText.setText('Score: ' + Math.floor(score));
  }

  // send score to backend server
  function sendScore(finalScore) {
    const payload = { score: Math.floor(finalScore), initData: initData };
    fetch('/api/score', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify(payload)
    }).catch(e => console.error('Send score failed', e));
  }

  </script>
</body>
</html>
